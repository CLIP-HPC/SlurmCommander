// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package openapi

const (
	TokenScopes = "token.Scopes"
	UserScopes  = "user.Scopes"
)

// Defines values for V0039JobPropertiesExclusive.
const (
	False V0039JobPropertiesExclusive = "false"
	Mcs   V0039JobPropertiesExclusive = "mcs"
	True  V0039JobPropertiesExclusive = "true"
	User  V0039JobPropertiesExclusive = "user"
)

// Defines values for V0039JobPropertiesGresFlags.
const (
	DisableBinding V0039JobPropertiesGresFlags = "disable-binding"
	EnforceBinding V0039JobPropertiesGresFlags = "enforce-binding"
)

// Defines values for V0039JobPropertiesOpenMode.
const (
	Append   V0039JobPropertiesOpenMode = "append"
	Truncate V0039JobPropertiesOpenMode = "truncate"
)

// Defines values for V0039PingPing.
const (
	DOWN V0039PingPing = "DOWN"
	UP   V0039PingPing = "UP"
)

// Defines values for V0039Signal.
const (
	ABRT V0039Signal = "ABRT"
	ALRM V0039Signal = "ALRM"
	CONT V0039Signal = "CONT"
	HUP  V0039Signal = "HUP"
	INT  V0039Signal = "INT"
	KILL V0039Signal = "KILL"
	QUIT V0039Signal = "QUIT"
	STOP V0039Signal = "STOP"
	TERM V0039Signal = "TERM"
	TSTP V0039Signal = "TSTP"
	TTIN V0039Signal = "TTIN"
	TTOU V0039Signal = "TTOU"
	URG  V0039Signal = "URG"
	USR1 V0039Signal = "USR1"
	USR2 V0039Signal = "USR2"
)

// V0039Diag defines model for v0.0.39_diag.
type V0039Diag struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`
	Meta   *V0039Meta    `json:"meta,omitempty"`

	// Slurm statistics
	Statistics *struct {
		// Agent count
		AgentCount *int `json:"agent_count,omitempty"`

		// Agent queue size
		AgentQueueSize *int `json:"agent_queue_size,omitempty"`

		// Agent thread count
		AgentThreadCount *int `json:"agent_thread_count,omitempty"`

		// Backfill Schedule currently active
		BfActive *bool `json:"bf_active,omitempty"`

		// Total backfilled heterogeneous job components
		BfBackfilledHetJobs *int `json:"bf_backfilled_het_jobs,omitempty"`

		// Total backfilled jobs (since last slurm start)
		BfBackfilledJobs *int `json:"bf_backfilled_jobs,omitempty"`

		// Backfill Schedule Total cycles
		BfCycleCounter *int `json:"bf_cycle_counter,omitempty"`

		// Backfill Schedule Last cycle time
		BfCycleLast *int `json:"bf_cycle_last,omitempty"`

		// Backfill Schedule Max cycle time
		BfCycleMax *int `json:"bf_cycle_max,omitempty"`

		// Backfill Schedule Mean cycle
		BfCycleMean *int `json:"bf_cycle_mean,omitempty"`

		// Backfill Schedule Depth Mean
		BfDepthMean *int `json:"bf_depth_mean,omitempty"`

		// Backfill Schedule Depth Mean (try sched)
		BfDepthMeanTry *int `json:"bf_depth_mean_try,omitempty"`

		// Total backfilled jobs (since last stats cycle start)
		BfLastBackfilledJobs *int `json:"bf_last_backfilled_jobs,omitempty"`

		// Backfill Schedule Last depth cycle
		BfLastDepth *int `json:"bf_last_depth,omitempty"`

		// Backfill Schedule Mean cycle (try sched)
		BfLastDepthTry *int `json:"bf_last_depth_try,omitempty"`

		// Backfill Schedule Last queue length
		BfQueueLen *int `json:"bf_queue_len,omitempty"`

		// Backfill Schedule Mean queue length
		BfQueueLenMean *int `json:"bf_queue_len_mean,omitempty"`

		// Backfill Schedule Last table size
		BfTableSize *int `json:"bf_table_size,omitempty"`

		// Backfill Schedule Mean table size
		BfTableSizeMean *int `json:"bf_table_size_mean,omitempty"`

		// Last cycle timestamp
		BfWhenLastCycle *int `json:"bf_when_last_cycle,omitempty"`

		// DBD Agent queue size
		DbdAgentQueueSize *int `json:"dbd_agent_queue_size,omitempty"`

		// Latency for 1000 calls to gettimeofday()
		GettimeofdayLatency *int `json:"gettimeofday_latency,omitempty"`

		// Job states timestamp
		JobStatesTs *int `json:"job_states_ts,omitempty"`

		// Job cancelled
		JobsCanceled *int `json:"jobs_canceled,omitempty"`

		// Job completed
		JobsCompleted *int `json:"jobs_completed,omitempty"`

		// Job failed
		JobsFailed *int `json:"jobs_failed,omitempty"`

		// Job pending
		JobsPending *int `json:"jobs_pending,omitempty"`

		// Job running
		JobsRunning *int `json:"jobs_running,omitempty"`

		// Job started
		JobsStarted *int `json:"jobs_started,omitempty"`

		// Job submitted
		JobsSubmitted *int `json:"jobs_submitted,omitempty"`

		// partition records packed
		PartsPacked *int `json:"parts_packed,omitempty"`

		// generation time
		ReqTime *int `json:"req_time,omitempty"`

		// data since
		ReqTimeStart *int `json:"req_time_start,omitempty"`

		// Remote Procedure Call statistics by message type
		RpcsByMessageType *[]V0039DiagRpcm `json:"rpcs_by_message_type,omitempty"`

		// Remote Procedure Call statistics by user
		RpcsByUser *[]V0039DiagRpcu `json:"rpcs_by_user,omitempty"`

		// Main Schedule last cycle
		ScheduleCycleLast *int `json:"schedule_cycle_last,omitempty"`

		// Main Schedule max cycle
		ScheduleCycleMax *int `json:"schedule_cycle_max,omitempty"`

		// Average time for Schedule Max cycle
		ScheduleCycleMean *int `json:"schedule_cycle_mean,omitempty"`

		// Average depth for Schedule Max cycle
		ScheduleCycleMeanDepth *int `json:"schedule_cycle_mean_depth,omitempty"`

		// Main Schedule Cycles per minute
		ScheduleCyclePerMinute *int `json:"schedule_cycle_per_minute,omitempty"`

		// Main Schedule cycle iterations
		ScheduleCycleTotal *int `json:"schedule_cycle_total,omitempty"`

		// Main Schedule Last queue length
		ScheduleQueueLength *int `json:"schedule_queue_length,omitempty"`

		// Server thread count
		ServerThreadCount *int `json:"server_thread_count,omitempty"`
	} `json:"statistics,omitempty"`
}

// V0039DiagRpcm defines model for v0.0.39_diag_rpcm.
type V0039DiagRpcm struct {
	// average time
	AverageTime *int `json:"average_time,omitempty"`

	// rpc count
	Count *int `json:"count,omitempty"`

	// message type
	MessageType *string `json:"message_type,omitempty"`

	// total time
	TotalTime *int `json:"total_time,omitempty"`

	// message type id
	TypeId *int `json:"type_id,omitempty"`
}

// V0039DiagRpcu defines model for v0.0.39_diag_rpcu.
type V0039DiagRpcu struct {
	// average time
	AverageTime *int `json:"average_time,omitempty"`

	// rpc count
	Count *int `json:"count,omitempty"`

	// total time
	TotalTime *int `json:"total_time,omitempty"`

	// user
	User *string `json:"user,omitempty"`

	// user id
	UserId *int `json:"user_id,omitempty"`
}

// V0039Error defines model for v0.0.39_error.
type V0039Error struct {
	// error message
	Error *string `json:"error,omitempty"`

	// Slurm internal error number
	ErrorNumber *int `json:"error_number,omitempty"`
}

// Slurm errors
type V0039Errors = []V0039Error

// V0039JobProperties defines model for v0.0.39_job_properties.
type V0039JobProperties struct {
	// Charge resources used by this job to specified account.
	Account *string `json:"account,omitempty"`

	// Define the job accounting and profiling sampling intervals.
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// Arguments to the script.
	Argv *[]string `json:"argv,omitempty"`

	// Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
	Array *string `json:"array,omitempty"`

	// features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
	BeginTime *int64 `json:"begin_time,omitempty"`

	// Burst buffer specification.
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// Specifies features that a federated cluster must have to have a sibling job submitted to it.
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// An arbitrary comment.
	Comment *string `json:"comment,omitempty"`

	// node features required by job.
	Constraints *string `json:"constraints,omitempty"`

	// absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// Count of specialized threads per node reserved by the job for system operations and not used by the application.
	CoreSpecification *int `json:"core_specification,omitempty"`

	// Restrict node selection to nodes with at least the specified number of cores per socket.
	CoresPerSocket *int `json:"cores_per_socket,omitempty"`

	// Cpu binding
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// Cpu binding hint
	CpuBindingHint *string `json:"cpu_binding_hint,omitempty"`

	// Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// Number of CPUs requested per allocated GPU.
	CpusPerGpu *string `json:"cpus_per_gpu,omitempty"`

	// Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
	CpusPerTask *int `json:"cpus_per_task,omitempty"`

	// Instruct Slurm to connect the batch script's standard output directly to the file name.
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])).
	Deadline *string `json:"deadline,omitempty"`

	// Do not reboot nodes in order to satisfied this job's feature specification if the job has been eligible to run for less than this time period.
	DelayBoot *int `json:"delay_boot,omitempty"`

	// Defer the start of this job until the specified dependencies have been satisfied completed.
	Dependency *string `json:"dependency,omitempty"`

	// Specify alternate distribution methods for remote processes.
	Distribution *string `json:"distribution,omitempty"`

	// Dictionary of environment entries.
	Environment map[string]interface{} `json:"environment"`

	// The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
	Exclusive *V0039JobPropertiesExclusive `json:"exclusive,omitempty"`

	// Load new login environment for user on job node.
	GetUserEnvironment *bool `json:"get_user_environment,omitempty"`

	// Requested binding of tasks to GPU.
	GpuBinding *string `json:"gpu_binding,omitempty"`

	// Requested GPU frequency.
	GpuFrequency *string `json:"gpu_frequency,omitempty"`

	// GPUs per job.
	Gpus *string `json:"gpus,omitempty"`

	// GPUs per node.
	GpusPerNode *string `json:"gpus_per_node,omitempty"`

	// GPUs per socket.
	GpusPerSocket *string `json:"gpus_per_socket,omitempty"`

	// GPUs per task.
	GpusPerTask *string `json:"gpus_per_task,omitempty"`

	// Specifies a comma delimited list of generic consumable resources.
	Gres *string `json:"gres,omitempty"`

	// Specify generic resource task binding options.
	GresFlags *V0039JobPropertiesGresFlags `json:"gres_flags,omitempty"`

	// Specify the job is to be submitted in a held state (priority of zero).
	Hold *bool `json:"hold,omitempty"`

	// If a job has an invalid dependency, then Slurm is to terminate it.
	KillOnInvalidDependency *bool `json:"kill_on_invalid_dependency,omitempty"`

	// Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
	Licenses *string `json:"licenses,omitempty"`

	// Notify user by email when certain event types occur.
	MailType *string `json:"mail_type,omitempty"`

	// User to receive email notification of state changes as defined by mail_type.
	MailUser *string `json:"mail_user,omitempty"`

	// This parameter is a group among the groups of the user.
	McsLabel *string `json:"mcs_label,omitempty"`

	// Bind tasks to memory.
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// Minimum real memory per cpu (MB).
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// Minimum memory required per allocated GPU.
	MemoryPerGpu *int `json:"memory_per_gpu,omitempty"`

	// Minimum real memory per node (MB).
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// Minimum number of CPUs per node.
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// If a range of node counts is given, prefer the smaller count.
	MinimumNodes *bool `json:"minimum_nodes,omitempty"`

	// Specify a name for the job allocation.
	Name *string `json:"name,omitempty"`

	// Run the job with an adjusted scheduling priority within Slurm.
	Nice *int `json:"nice,omitempty"`

	// Do not automatically terminate a job if one of the nodes it has been allocated fails.
	NoKill *bool `json:"no_kill,omitempty"`

	// Request that a minimum of minnodes nodes and a maximum node count.
	Nodes *[]int `json:"nodes,omitempty"`

	// Open the output and error files using append or truncate mode as specified.
	OpenMode *V0039JobPropertiesOpenMode `json:"open_mode,omitempty"`

	// Request a specific partition for the resource allocation.
	Partition *string `json:"partition,omitempty"`

	// Comma delimited list of features for scheduler to prefer but not a strict requirement like a constraint. This value is not dumped but can be used for job submission.
	Prefer *string `json:"prefer,omitempty"`

	// Request a specific job priority.
	Priority *string `json:"priority,omitempty"`

	// Request a quality of service for the job.
	Qos *string `json:"qos,omitempty"`

	// Specifies that the batch job should eligible to being requeue.
	Requeue *bool `json:"requeue,omitempty"`

	// Allocate resources for the job from the named reservation.
	Reservation *string `json:"reservation,omitempty"`

	// When a job is within sig_time seconds of its end time, send it the signal sig_num.
	Signal *string `json:"signal,omitempty"`

	// Restrict node selection to nodes with at least the specified number of sockets.
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
	SpreadJob *bool `json:"spread_job,omitempty"`

	// Instruct Slurm to connect the batch script's standard error directly to the file name.
	StandardError *string `json:"standard_error,omitempty"`

	// Instruct Slurm to connect the batch script's standard input directly to the file name specified.
	StandardInput *string `json:"standard_input,omitempty"`

	// Instruct Slurm to connect the batch script's standard output directly to the file name.
	StandardOutput *string `json:"standard_output,omitempty"`

	// Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
	Tasks *int `json:"tasks,omitempty"`

	// Request the maximum ntasks be invoked on each core.
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// Request the maximum ntasks be invoked on each node.
	TasksPerNode *int `json:"tasks_per_node,omitempty"`

	// Request the maximum ntasks be invoked on each socket.
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// Count of specialized threads per node reserved by the job for system operations and not used by the application.
	ThreadSpecification *int `json:"thread_specification,omitempty"`

	// Restrict node selection to nodes with at least the specified number of threads per core.
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// Step time limit.
	TimeLimit *int `json:"time_limit,omitempty"`

	// Minimum run time in minutes.
	TimeMinimum *int `json:"time_minimum,omitempty"`

	// Do not begin execution until all nodes are ready for use.
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// Specify wckey to be used with job.
	Wckey *string `json:"wckey,omitempty"`
}

// The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
type V0039JobPropertiesExclusive string

// Specify generic resource task binding options.
type V0039JobPropertiesGresFlags string

// Open the output and error files using append or truncate mode as specified.
type V0039JobPropertiesOpenMode string

// V0039JobResources defines model for v0.0.39_job_resources.
type V0039JobResources struct {
	// number of assigned job cpus
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// number of assigned job hosts
	AllocatedHosts *int `json:"allocated_hosts,omitempty"`

	// array of allocated nodes
	//AllocatedNodes *[]V0039NodeAllocation `json:"allocated_nodes,omitempty"`

	// list of assigned job nodes
	Nodes *string `json:"nodes,omitempty"`
}

// V0039JobResponseProperties defines model for v0.0.39_job_response_properties.
type V0039JobResponseProperties struct {
	// Charge resources used by this job to specified account
	Account *string `json:"account,omitempty"`

	// time job is eligible for running
	AccrueTime *int64 `json:"accrue_time,omitempty"`

	// administrator's arbitrary comment
	AdminComment *string `json:"admin_comment,omitempty"`

	// job_id of a job array or 0 if N/A
	ArrayJobId *int `json:"array_job_id,omitempty"`

	// Maximum number of running array tasks
	ArrayMaxTasks *int `json:"array_max_tasks,omitempty"`

	// task_id of a job array
	ArrayTaskId *int `json:"array_task_id,omitempty"`

	// string expression of task IDs in this record
	ArrayTaskString *string `json:"array_task_string,omitempty"`

	// association id for job
	AssociationId *int `json:"association_id,omitempty"`

	// features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// if batch: queued job with script
	BatchFlag *bool `json:"batch_flag,omitempty"`

	// name of host running batch script
	BatchHost *string `json:"batch_host,omitempty"`

	// billable TRES
	BillableTres *float32 `json:"billable_tres,omitempty"`

	// burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// burst buffer state info
	BurstBufferState *string `json:"burst_buffer_state,omitempty"`

	// name of cluster that the job is on
	Cluster *string `json:"cluster,omitempty"`

	// comma separated list of required cluster features
	ClusterFeatures *string `json:"cluster_features,omitempty"`

	// command to be executed
	Command *string `json:"command,omitempty"`

	// arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// specialized core count
	CoreSpec *string `json:"core_spec,omitempty"`

	// cores per socket required by job
	CoresPerSocket *string `json:"cores_per_socket,omitempty"`

	// cpu frequency governor
	CpuFrequencyGovernor *string `json:"cpu_frequency_governor,omitempty"`

	// Maximum cpu frequency
	CpuFrequencyMaximum *string `json:"cpu_frequency_maximum,omitempty"`

	// Minimum cpu frequency
	CpuFrequencyMinimum *string `json:"cpu_frequency_minimum,omitempty"`

	// minimum number of cpus required by job
	Cpus *int `json:"cpus,omitempty"`

	// number of processors required for each task
	CpusPerTask *string `json:"cpus_per_task,omitempty"`

	// semicolon delimited list of TRES=# values
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// pathname of working directory
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// job start deadline
	Deadline *int `json:"deadline,omitempty"`

	// command to be executed
	DelayBoot *int `json:"delay_boot,omitempty"`

	// synchronize job execution with other jobs
	Dependency *string `json:"dependency,omitempty"`

	// highest exit code of all job steps
	DerivedExitCode *int `json:"derived_exit_code,omitempty"`

	// time job is eligible for running
	EligibleTime *int64 `json:"eligible_time,omitempty"`

	// time of termination, actual or expected
	EndTime *int64 `json:"end_time,omitempty"`

	// comma separated list of excluded nodes
	ExcludedNodes *string `json:"excluded_nodes,omitempty"`

	// exit code for job
	ExitCode *int `json:"exit_code,omitempty"`

	// comma separated list of required features
	Features *string `json:"features,omitempty"`

	// Origin cluster's name
	FederationOrigin *string `json:"federation_origin,omitempty"`

	// string of active sibling names
	FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

	// string of viable sibling names
	FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

	// Job flags
	Flags *[]string `json:"flags,omitempty"`

	// Job flags
	GresDetail *[]string `json:"gres_detail,omitempty"`

	// group job submitted as
	GroupId *int `json:"group_id,omitempty"`

	// job ID of hetjob leader
	HetJobId *int `json:"het_job_id,omitempty"`

	// job IDs for all components
	HetJobIdSet *string `json:"het_job_id_set,omitempty"`

	// HetJob component offset from leader
	HetJobOffset *int `json:"het_job_offset,omitempty"`

	// job ID
	JobId        *int               `json:"job_id,omitempty"`
	JobResources *V0039JobResources `json:"job_resources,omitempty"`

	// state of the job
	JobState *string `json:"job_state,omitempty"`

	// last time job was evaluated for scheduling
	LastSchedEvaluation *int `json:"last_sched_evaluation,omitempty"`

	// licenses required by the job
	Licenses *string `json:"licenses,omitempty"`

	// maximum number of cpus usable by job
	MaxCpus *int `json:"max_cpus,omitempty"`

	// maximum number of nodes usable by job
	MaxNodes *int `json:"max_nodes,omitempty"`

	// mcs_label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// minimum real memory per cpu
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// minimum real memory per node
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// semicolon delimited list of TRES=# values
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// minimum # CPUs per node
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// minimum tmp disk per node
	MinimumTmpDiskPerNode *int `json:"minimum_tmp_disk_per_node,omitempty"`

	// name of the job
	Name *string `json:"name,omitempty"`

	// requested priority change
	Nice *int `json:"nice,omitempty"`

	// minimum number of nodes required by job
	NodeCount *int `json:"node_count,omitempty"`

	// list of nodes allocated to job
	Nodes *string `json:"nodes,omitempty"`

	// name of assigned partition
	Partition *string `json:"partition,omitempty"`

	// time job ran prior to last suspend
	PreSusTime *int64 `json:"pre_sus_time,omitempty"`

	// preemption signal time
	PreemptTime *int64 `json:"preempt_time,omitempty"`

	// relative priority of the job
	Priority *int `json:"priority,omitempty"`

	// Job profiling requested
	Profile *[]string `json:"profile,omitempty"`

	// Quality of Service
	Qos *string `json:"qos,omitempty"`

	// node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// enable or disable job requeue option
	Requeue *bool `json:"requeue,omitempty"`

	// comma separated list of required nodes
	RequiredNodes *string `json:"required_nodes,omitempty"`

	// time of latest size change
	ResizeTime *int64 `json:"resize_time,omitempty"`

	// count of job restarts
	RestartCnt *int `json:"restart_cnt,omitempty"`

	// reservation name
	ResvName *string `json:"resv_name,omitempty"`

	// type and if job can share nodes with other jobs
	Shared *string `json:"shared,omitempty"`

	// details requested
	ShowFlags *[]string `json:"show_flags,omitempty"`

	// sockets per board required by job
	SocketsPerBoard *int `json:"sockets_per_board,omitempty"`

	// sockets per node required by job
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// pathname of job's stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// pathname of job's stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// pathname of job's stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// time execution begins, actual or expected
	StartTime *int64 `json:"start_time,omitempty"`

	// optional details for state_reason
	StateDescription *string `json:"state_description,omitempty"`

	// reason job still pending or failed
	StateReason *string `json:"state_reason,omitempty"`

	// time of job submission
	SubmitTime *int64 `json:"submit_time,omitempty"`

	// time job last suspended or resumed
	SuspendTime *int64 `json:"suspend_time,omitempty"`

	// slurmctld's arbitrary comment
	SystemComment *string `json:"system_comment,omitempty"`

	// requested task count
	Tasks *int `json:"tasks,omitempty"`

	// number of tasks to invoke on each board
	TasksPerBoard *int `json:"tasks_per_board,omitempty"`

	// number of tasks to invoke on each core
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// number of tasks to invoke on each socket
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// specialized thread count
	ThreadSpec *string `json:"thread_spec,omitempty"`

	// threads per core required by job
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// maximum run time in minutes
	TimeLimit *int64 `json:"time_limit,omitempty"`

	// minimum run time in minutes
	TimeMinimum *int64 `json:"time_minimum,omitempty"`

	// tres used in the job
	TresAllocStr *string `json:"tres_alloc_str,omitempty"`

	// Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// semicolon delimited list of TRES=# values
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// semicolon delimited list of TRES=# values
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// semicolon delimited list of TRES=# values
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// semicolon delimited list of TRES=# values
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// tres reqeusted in the job
	TresReqStr *string `json:"tres_req_str,omitempty"`

	// user id the job runs as
	UserId *int64 `json:"user_id,omitempty"`

	// user the job runs as
	UserName *string `json:"user_name,omitempty"`

	// wckey for job
	Wckey *string `json:"wckey,omitempty"`
}

// V0039JobSubmission defines model for v0.0.39_job_submission.
type V0039JobSubmission struct {
	Job *V0039JobProperties `json:"job,omitempty"`

	// Properties of an HetJob
	Jobs *[]V0039JobProperties `json:"jobs,omitempty"`

	// Executable script (full contents) to run in batch step
	Script string `json:"script"`
}

// V0039JobSubmissionResponse defines model for v0.0.39_job_submission_response.
type V0039JobSubmissionResponse struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`

	// new job ID
	JobId *int `json:"job_id,omitempty"`

	// Message to user from job_submit plugin
	JobSubmitUserMsg *string    `json:"job_submit_user_msg,omitempty"`
	Meta             *V0039Meta `json:"meta,omitempty"`

	// new job step ID
	StepId *string `json:"step_id,omitempty"`
}

// V0039JobsResponse defines model for v0.0.39_jobs_response.
type V0039JobsResponse struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`

	// job descriptions
	Jobs *[]V0039JobResponseProperties `json:"jobs,omitempty"`
	Meta *V0039Meta                    `json:"meta,omitempty"`
}

// V0039License defines model for v0.0.39_license.
type V0039License struct {
	// number of licenses available
	Free *int `json:"Free,omitempty"`

	// name of license
	LicenseName *string `json:"LicenseName,omitempty"`

	// license is remote
	Remote *bool `json:"Remote,omitempty"`

	// number of licenses reserved
	Reserved *int `json:"Reserved,omitempty"`

	// total number of licenses
	Total *int `json:"Total,omitempty"`

	// number of licenses in use
	Used *int `json:"Used,omitempty"`
}

// V0039Licenses defines model for v0.0.39_licenses.
type V0039Licenses struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`

	// licenses info
	Licenses *[]V0039License `json:"licenses,omitempty"`
}

// V0039Meta defines model for v0.0.39_meta.
type V0039Meta struct {
	// Slurm information
	Slurm *struct {
		// version specifier
		Release *string `json:"release,omitempty"`
		Version *struct {
			Major *string `json:"major,omitempty"`
			Micro *string `json:"micro,omitempty"`
			Minor *string `json:"minor,omitempty"`
		} `json:"version,omitempty"`
	} `json:"Slurm,omitempty"`
	Plugin *struct {
		Name *string `json:"name,omitempty"`
		Type *string `json:"type,omitempty"`
	} `json:"plugin,omitempty"`
}

// V0039Node defines model for v0.0.39_node.
type V0039Node struct {
	// list of a node's available features
	ActiveFeatures *string `json:"active_features,omitempty"`

	// state after reboot
	Address *string `json:"address,omitempty"`

	// Allocated CPUs
	AllocCpus *int64 `json:"alloc_cpus,omitempty"`

	// Allocated memory (MB)
	AllocMemory *int64 `json:"alloc_memory,omitempty"`

	// computer architecture
	Architecture *string `json:"architecture,omitempty"`

	// total number of boards per node
	Boards *int `json:"boards,omitempty"`

	// timestamp of node boot
	BootTime *int64 `json:"boot_time,omitempty"`

	// BcastAddr
	BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

	// number of cores per socket
	Cores *int `json:"cores,omitempty"`

	// Default task binding
	CpuBinding *int `json:"cpu_binding,omitempty"`

	// CPU load * 100
	CpuLoad *int64 `json:"cpu_load,omitempty"`

	// configured count of cpus running on the node
	Cpus     *int    `json:"cpus,omitempty"`
	Features *string `json:"features,omitempty"`

	// free memory in MiB
	FreeMemory *int `json:"free_memory,omitempty"`

	// list of a node's generic resources
	Gres *string `json:"gres,omitempty"`

	// list of drained GRES
	GresDrained *string `json:"gres_drained,omitempty"`

	// list of GRES in current use
	GresUsed *string `json:"gres_used,omitempty"`

	// node's hostname
	Hostname *string `json:"hostname,omitempty"`

	// Idle CPUs
	IdleCpus *int64 `json:"idle_cpus,omitempty"`

	// mcs label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// node name to slurm
	Name *string `json:"name,omitempty"`

	// state after reboot
	NextStateAfterReboot *string `json:"next_state_after_reboot,omitempty"`

	// node state flags
	NextStateAfterRebootFlags *[]string `json:"next_state_after_reboot_flags,omitempty"`

	// operating system
	OperatingSystem *string `json:"operating_system,omitempty"`

	// User allowed to use this node
	Owner *string `json:"owner,omitempty"`

	// assigned partitions
	Partitions *[]string `json:"partitions,omitempty"`

	// TCP port number of the slurmd
	Port *int `json:"port,omitempty"`

	// configured MB of real memory on the node
	RealMemory *int `json:"real_memory,omitempty"`

	// reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// Time stamp when reason was set
	ReasonChangedAt *int `json:"reason_changed_at,omitempty"`

	// User that set the reason
	ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

	// timestamp of slurmd startup
	SlurmdStartTime *int64 `json:"slurmd_start_time,omitempty"`

	// Slurmd version
	SlurmdVersion *string `json:"slurmd_version,omitempty"`

	// total number of sockets per node
	Sockets *int `json:"sockets,omitempty"`

	// current node state
	State *string `json:"state,omitempty"`

	// node state flags
	StateFlags *[]string `json:"state_flags,omitempty"`

	// configured MB of total disk in TMP_FS
	TemporaryDisk *int `json:"temporary_disk,omitempty"`

	// number of threads per core
	Threads *int `json:"threads,omitempty"`

	// TRES on node
	Tres *string `json:"tres,omitempty"`

	// TRES used on node
	TresUsed *string `json:"tres_used,omitempty"`

	// TRES weight used on node
	TresWeighted *float64 `json:"tres_weighted,omitempty"`

	// arbitrary priority of node for scheduling
	Weight *int `json:"weight,omitempty"`
}

// V0039NodeAllocation defines model for v0.0.39_node_allocation.
type V0039NodeAllocation struct {
	// number of assigned job CPUs
	Cpus *int `json:"cpus,omitempty"`

	// amount of assigned job memory
	Memory *int `json:"memory,omitempty"`

	// node name
	Nodename *string `json:"nodename,omitempty"`

	// assignment status of each socket by numeric socket id
	Sockets *struct {
		// assignment status of each core by core id in each socket
		Cores *map[string]interface{} `json:"cores,omitempty"`
	} `json:"sockets,omitempty"`
}

// V0039NodesResponse defines model for v0.0.39_nodes_response.
type V0039NodesResponse struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`
	Meta   *V0039Meta    `json:"meta,omitempty"`

	// nodes info
	Nodes *[]V0039Node `json:"nodes,omitempty"`
}

// V0039Partition defines model for v0.0.39_partition.
type V0039Partition struct {
	// comma delimited list of accounts
	AllowedAccounts *string `json:"allowed_accounts,omitempty"`

	// list names of allowed allocating nodes
	AllowedAllocationNodes *string `json:"allowed_allocation_nodes,omitempty"`

	// comma delimited list of groups
	AllowedGroups *string `json:"allowed_groups,omitempty"`

	// comma delimited list of qos
	AllowedQos *string `json:"allowed_qos,omitempty"`

	// name of alternate partition
	Alternative *string `json:"alternative,omitempty"`

	// TRES billing weights
	BillingWeights *string `json:"billing_weights,omitempty"`

	// default MB memory per allocated CPU. May be INFINITE for all memory.
	DefaultMemoryPerCpu *string `json:"default_memory_per_cpu,omitempty"`

	// default MB memory per allocated node. May be INFINITE for all memory.
	DefaultMemoryPerNode *string `json:"default_memory_per_node,omitempty"`

	// default time limit (minutes)
	DefaultTimeLimit *int64 `json:"default_time_limit,omitempty"`

	// comma delimited list of denied accounts
	DeniedAccounts *string `json:"denied_accounts,omitempty"`

	// comma delimited list of denied qos
	DeniedQos *string `json:"denied_qos,omitempty"`

	// partition options
	Flags *[]string `json:"flags,omitempty"`

	// Max time limit per job
	MaxTimeLimit *int64 `json:"max_time_limit,omitempty"`

	// maximum allocated CPUs per node
	MaximumCpusPerNode *int `json:"maximum_cpus_per_node,omitempty"`

	// maximum memory per allocated CPU (MiB). May be UNLIMITED for all memory.
	MaximumMemoryPerCpu *string `json:"maximum_memory_per_cpu,omitempty"`

	// maximum memory per allocated node (MiB). May be UNLIMITED for all memory.
	MaximumMemoryPerNode *string `json:"maximum_memory_per_node,omitempty"`

	// Max nodes per job
	MaximumNodesPerJob *int `json:"maximum_nodes_per_job,omitempty"`

	// Min number of nodes per job
	MinNodesPerJob *int `json:"min_nodes_per_job,omitempty"`

	// Partition name
	Name *string `json:"name,omitempty"`

	// list names of nodes in partition
	Nodes *string `json:"nodes,omitempty"`

	// job's time limit can be exceeded by this number of minutes before cancellation
	OverTimeLimit *int `json:"over_time_limit,omitempty"`

	// preemption grace time (seconds)
	PreemptionGraceTime *int64 `json:"preemption_grace_time,omitempty"`

	// preemption type
	PreemptionMode *[]string `json:"preemption_mode,omitempty"`

	// job priority weight factor
	PriorityJobFactor *int `json:"priority_job_factor,omitempty"`

	// tier for scheduling and preemption
	PriorityTier *int `json:"priority_tier,omitempty"`

	// partition QOS name
	Qos *string `json:"qos,omitempty"`

	// Partition state
	State *string `json:"state,omitempty"`

	// Total cpus in partition
	TotalCpus *int `json:"total_cpus,omitempty"`

	// Total number of nodes in partition
	TotalNodes *int `json:"total_nodes,omitempty"`

	// configured TRES in partition
	Tres *string `json:"tres,omitempty"`
}

// V0039PartitionsResponse defines model for v0.0.39_partitions_response.
type V0039PartitionsResponse struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`
	Meta   *V0039Meta    `json:"meta,omitempty"`

	// partition info
	Partitions *[]V0039Partition `json:"partitions,omitempty"`
}

// V0039Ping defines model for v0.0.39_ping.
type V0039Ping struct {
	// slurm controller hostname
	Hostname *string `json:"hostname,omitempty"`

	// slurm controller mode
	Mode *string `json:"mode,omitempty"`

	// slurm controller host up
	Ping *V0039PingPing `json:"ping,omitempty"`

	// slurm controller status
	Status *int `json:"status,omitempty"`
}

// slurm controller host up
type V0039PingPing string

// V0039Pings defines model for v0.0.39_pings.
type V0039Pings struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`
	Meta   *V0039Meta    `json:"meta,omitempty"`

	// slurm controller pings
	Pings *[]V0039Ping `json:"pings,omitempty"`
}

// V0039Reservation defines model for v0.0.39_reservation.
type V0039Reservation struct {
	// Allowed accounts
	Accounts *string `json:"accounts,omitempty"`

	// Reserved burst buffer
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// Number of reserved cores
	CoreCount *int `json:"core_count,omitempty"`

	// Number of reserved specialized cores
	CoreSpecCnt *int `json:"core_spec_cnt,omitempty"`

	// End time of the reservation
	EndTime *int `json:"end_time,omitempty"`

	// List of features
	Features *string `json:"features,omitempty"`

	// Reservation options
	Flags *[]string `json:"flags,omitempty"`

	// List of groups permitted to use the reserved nodes
	Groups *string `json:"groups,omitempty"`

	// List of licenses
	Licenses *string `json:"licenses,omitempty"`

	// Maximum delay in which jobs outside of the reservation will be permitted to overlap once any jobs are queued for the reservation
	MaxStartDelay *int `json:"max_start_delay,omitempty"`

	// Reservationn name
	Name *string `json:"name,omitempty"`

	// Count of nodes reserved
	NodeCount *int `json:"node_count,omitempty"`

	// List of reserved nodes
	NodeList *string `json:"node_list,omitempty"`

	// Partition
	Partition *string `json:"partition,omitempty"`

	// If PURGE_COMP flag is set the amount of seconds this reservation will sit idle until it is revoked
	PurgeCompleted *struct {
		// amount of seconds this reservation will sit idle until it is revoked
		Time *int `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`

	// Start time of reservation
	StartTime *int `json:"start_time,omitempty"`

	// List of TRES
	Tres *string `json:"tres,omitempty"`

	// List of users
	Users *string `json:"users,omitempty"`

	// amount of power to reserve in watts
	Watts *int `json:"watts,omitempty"`
}

// V0039ReservationsResponse defines model for v0.0.39_reservations_response.
type V0039ReservationsResponse struct {
	// slurm errors
	Errors *[]V0039Error `json:"errors,omitempty"`
	Meta   *V0039Meta    `json:"meta,omitempty"`

	// reservation info
	Reservations *[]V0039Reservation `json:"reservations,omitempty"`
}

// POSIX signal name
type V0039Signal string

// SubmitJobJSONBody defines parameters for SubmitJob.
type SubmitJobJSONBody = V0039JobSubmission

// CancelJobParams defines parameters for CancelJob.
type CancelJobParams struct {
	// signal to send to job
	Signal *V0039Signal `form:"signal,omitempty" json:"signal,omitempty"`
}

// UpdateJobJSONBody defines parameters for UpdateJob.
type UpdateJobJSONBody = V0039JobProperties

// GetJobsParams defines parameters for GetJobs.
type GetJobsParams struct {
	// Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// GetNodesParams defines parameters for GetNodes.
type GetNodesParams struct {
	// Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// GetPartitionParams defines parameters for GetPartition.
type GetPartitionParams struct {
	// Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// GetPartitionsParams defines parameters for GetPartitions.
type GetPartitionsParams struct {
	// Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// GetReservationParams defines parameters for GetReservation.
type GetReservationParams struct {
	// Filter if no reservation (not limited to reservation in URL) changed since update_time.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// GetReservationsParams defines parameters for GetReservations.
type GetReservationsParams struct {
	// Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SubmitJobJSONRequestBody defines body for SubmitJob for application/json ContentType.
type SubmitJobJSONRequestBody = SubmitJobJSONBody

// UpdateJobJSONRequestBody defines body for UpdateJob for application/json ContentType.
type UpdateJobJSONRequestBody = UpdateJobJSONBody
